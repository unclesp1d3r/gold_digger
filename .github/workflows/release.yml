name: Release

on:
  push:
    tags:
      - "v[0-9]+.*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to release"
        required: true
        default: "v1.0.0"

permissions:
  contents: write
  id-token: write

jobs:
  resolve-tag:
    runs-on: ubuntu-22.04
    permissions:
      contents: read
    outputs:
      tag: ${{ steps.get-tag.outputs.tag }}
    steps:
      - id: get-tag
        shell: bash
        env:
          REF: ${{ github.ref }}
          INPUT_TAG: ${{ github.event.inputs.tag }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          if [[ "${EVENT_NAME}" == "workflow_dispatch" && -n "${INPUT_TAG}" ]]; then
            if [[ ! "${INPUT_TAG}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?(\+[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$ ]]; then
              echo "Error: Provided tag '${INPUT_TAG}' does not match semantic versioning pattern." >&2
              exit 1
            fi
            echo "tag=${INPUT_TAG}" >> "$GITHUB_OUTPUT"
          elif [[ "${REF}" == refs/tags/* ]]; then
            TAG="${REF#refs/tags/}"
            if [[ ! "${TAG}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?(\+[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$ ]]; then
              echo "Error: Extracted tag '${TAG}' does not match semantic versioning pattern." >&2
              exit 1
            fi
            echo "tag=${TAG}" >> "$GITHUB_OUTPUT"
          else
            echo "Error: No valid tag detected. Please provide a valid semantic version tag." >&2
            exit 1
          fi

  create-release:
    needs: resolve-tag
    runs-on: ubuntu-22.04
    permissions:
      contents: write
      id-token: write
    steps:
      - uses: actions/checkout@v5

      - name: Create GitHub Release
        uses: taiki-e/create-gh-release-action@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

  build-and-package:
    needs: create-release
    strategy:
      matrix:
        os: [ubuntu-22.04, macos-13, windows-2022]
    runs-on: ${{ matrix.os }}
    permissions:
      contents: write
    env:
      BIN_NAME: gold_digger
    steps:
      - uses: actions/checkout@v5

      - name: Install Rust (stable)
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: Swatinem/rust-cache@v2

      - name: Install just
        uses: extractions/setup-just@v3

      - name: Build release
        shell: bash
        run: |
          echo "ðŸ”¨ Building release with rustls (pure Rust TLS)..."
          just build-rustls

      - name: Upload binaries to Release
        uses: taiki-e/upload-rust-binary-action@v1
        with:
          bin: ${{ env.BIN_NAME }}
          tar: unix
          zip: windows
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify built binaries
        shell: bash
        run: |
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            if [[ ! -f "target/release/${{ env.BIN_NAME }}.exe" ]]; then
              echo "Error: Windows binary not found at target/release/${{ env.BIN_NAME }}.exe" >&2
              exit 1
            fi
            echo "âœ… Windows binary verified: target/release/${{ env.BIN_NAME }}.exe"
            # Test binary execution
            ./target/release/${{ env.BIN_NAME }}.exe --version || { echo "Error: binary --version check failed" >&2; exit 1; }
          else
            if [[ ! -f "target/release/${{ env.BIN_NAME }}" ]]; then
              echo "Error: Unix binary not found at target/release/${{ env.BIN_NAME }}" >&2
              exit 1
            fi
            echo "âœ… Unix binary verified: target/release/${{ env.BIN_NAME }}"
            # Test binary execution
            ./target/release/${{ env.BIN_NAME }} --version || { echo "Error: binary --version check failed" >&2; exit 1; }
          fi

  sbom-and-sign:
    needs: [build-and-package, resolve-tag]
    runs-on: ubuntu-22.04
    permissions:
      contents: write
      id-token: write
    steps:
      - uses: actions/checkout@v5

      - name: Install syft
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.9.2

      - name: Install jq for JSON validation
        run: |
          sudo apt-get update && sudo apt-get install -y --no-install-recommends jq
        env:
          DEBIAN_FRONTEND: noninteractive

      - name: Download release assets
        run: |
          mkdir -p dist
          gh release download "${{ needs.resolve-tag.outputs.tag }}" --dir dist
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate SBOMs and checksums
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          mkdir -p sbom checksums
          echo "ðŸ“¦ Processing release artifacts..."

          artifact_count=0
          for f in dist/*; do
            if [ -f "$f" ] && [[ "$f" != *.sig ]] && [[ "$f" != *.crt ]]; then
              base=$(basename "$f")
              echo "Processing: $base"

              # Generate SBOM
              echo "  ðŸ” Generating SBOM..."
              syft packages "file:$f" -o cyclonedx-json > "sbom/${base}.sbom.cdx.json"

              # Verify SBOM was created and is valid JSON
              if ! jq empty "sbom/${base}.sbom.cdx.json" 2>/dev/null; then
                echo "âŒ Error: Invalid SBOM generated for $base" >&2
                exit 1
              fi

              # Generate SHA256 checksum
              echo "  ðŸ” Generating checksum..."
              # Run sha256sum from dist directory to get relative paths in output
              (cd dist && sha256sum "$base") > "checksums/${base}.sha256"

              artifact_count=$((artifact_count + 1))
            fi
          done

          if [ "$artifact_count" -eq 0 ]; then
            echo "âŒ Error: No artifacts found to process" >&2
            exit 1
          fi

          # Create consolidated checksums file
          echo "ðŸ“‹ Creating consolidated checksums file..."
          cat checksums/*.sha256 > checksums/SHA256SUMS

          echo "âœ… Processed $artifact_count artifacts successfully"

      - name: Upload SBOMs and checksums
        uses: softprops/action-gh-release@v2
        with:
          files: |
            sbom/*.sbom.cdx.json
            checksums/SHA256SUMS
            checksums/*.sha256
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Sign artifacts
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          echo "ðŸ” Signing release artifacts with Cosign keyless OIDC..."

          signed_count=0
          for f in dist/*; do
            if [ -f "$f" ] && [[ "$f" != *.sig ]] && [[ "$f" != *.crt ]]; then
              base=$(basename "$f")
              echo "Signing: $base"

              cosign sign-blob --yes "$f" \
                --output-signature "${f}.sig" \
                --output-certificate "${f}.crt"

              # Verify signature files were created
              if [[ ! -f "${f}.sig" ]] || [[ ! -f "${f}.crt" ]]; then
                echo "âŒ Error: Signature files not created for $base" >&2
                exit 1
              fi

              # Verify signature (basic validation)
              # Build expected certificate identity dynamically from environment variables
              EXPECTED_IDENTITY="https://github.com/${{ github.repository }}/.github/workflows/${{ github.workflow }}@refs/heads/main"
              if ! cosign verify-blob --certificate "${f}.crt" --signature "${f}.sig" "$f" --certificate-identity-regexp "^${EXPECTED_IDENTITY}$" --certificate-oidc-issuer-regexp "^https://token\.actions\.githubusercontent\.com$"; then
                echo "âŒ Error: Signature verification failed for $base" >&2
                exit 1
              fi

              signed_count=$((signed_count + 1))
            fi
          done

          echo "âœ… Successfully signed $signed_count artifacts"

      - name: Verify all artifacts before upload
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          echo "ðŸ” Verifying all required artifacts are present..."

          # Check for SBOMs
          sbom_count=$(find sbom -name "*.sbom.cdx.json" | wc -l)
          if [ "$sbom_count" -eq 0 ]; then
            echo "âŒ Error: No SBOM files found" >&2
            exit 1
          fi
          echo "âœ… Found $sbom_count SBOM files"

          # Check for checksums
          if [[ ! -f "checksums/SHA256SUMS" ]]; then
            echo "âŒ Error: Consolidated checksums file not found" >&2
            exit 1
          fi
          checksum_count=$(find checksums -name "*.sha256" | wc -l)
          echo "âœ… Found consolidated checksums and $checksum_count individual checksum files"

          # Check for signatures
          sig_count=$(find dist -name "*.sig" | wc -l)
          crt_count=$(find dist -name "*.crt" | wc -l)
          if [ "$sig_count" -eq 0 ] || [ "$crt_count" -eq 0 ]; then
            echo "âŒ Error: Missing signature files (sig: $sig_count, crt: $crt_count)" >&2
            exit 1
          fi
          echo "âœ… Found $sig_count signature files and $crt_count certificate files"

          echo "ðŸŽ‰ All required artifacts verified successfully"

      - name: Upload signatures
        uses: softprops/action-gh-release@v2
        with:
          files: |
            dist/*.sig
            dist/*.crt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
