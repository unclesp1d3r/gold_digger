name: Release

on:
  push:
    tags:
      - "v[0-9]+.*"
  release:
    types: [published]
  workflow_run:
    workflows: ["Release Please"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to release"
        required: true
        default: "v1.0.0"

permissions:
  contents: write
  id-token: write

jobs:
  resolve-tag:
    runs-on: ubuntu-22.04
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    permissions:
      contents: read
      actions: read
    outputs:
      tag: ${{ steps.get-tag.outputs.tag }}
    steps:
      - id: get-tag
        shell: bash
        env:
          REF: ${{ github.ref }}
          INPUT_TAG: ${{ github.event.inputs.tag }}
          EVENT_NAME: ${{ github.event_name }}
          RELEASE_TAG: ${{ github.event.release.tag_name }}
          WORKFLOW_RUN_ID: ${{ github.event.workflow_run.id }}
          WORKFLOW_RUN_CONCLUSION: ${{ github.event.workflow_run.conclusion }}
          WORKFLOW_RUN_NAME: ${{ github.event.workflow_run.name }}
          WORKFLOW_RUN_HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Function to validate semantic versioning pattern
          validate_semver() {
            local tag="$1"
            if [[ ! "${tag}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?(\+[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$ ]]; then
              echo "Error: Tag '${tag}' does not match semantic versioning pattern." >&2
              return 1
            fi
            return 0
          }

          # Priority 1: Manual workflow dispatch with explicit tag
          if [[ "${EVENT_NAME}" == "workflow_dispatch" && -n "${INPUT_TAG}" ]]; then
            echo "ğŸ“‹ Using manually provided tag from workflow dispatch"
            if ! validate_semver "${INPUT_TAG}"; then
              exit 1
            fi
            echo "tag=${INPUT_TAG}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Priority 2: Release event with direct tag access
          if [[ "${EVENT_NAME}" == "release" && -n "${RELEASE_TAG}" ]]; then
            echo "ğŸ“‹ Using tag from release event payload"
            if ! validate_semver "${RELEASE_TAG}"; then
              exit 1
            fi
            echo "tag=${RELEASE_TAG}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Priority 3: Tag push event - parse from GITHUB_REF
          if [[ "${REF}" == refs/tags/* ]]; then
            TAG="${REF#refs/tags/}"
            echo "ğŸ“‹ Using tag from push event: ${TAG}"
            if ! validate_semver "${TAG}"; then
              exit 1
            fi
            echo "tag=${TAG}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Priority 4: Workflow run from Release Please (restricted fallback)
          if [[ "${EVENT_NAME}" == "workflow_run" && "${WORKFLOW_RUN_CONCLUSION}" == "success" ]]; then
            # Only proceed if this is clearly from Release Please workflow
            if [[ "${WORKFLOW_RUN_NAME}" != "Release Please" ]]; then
              echo "âŒ Error: Workflow run is not from 'Release Please' workflow (got: ${WORKFLOW_RUN_NAME})" >&2
              exit 1
            fi

            # Only proceed if running on main branch (or specific release branch)
            if [[ "${WORKFLOW_RUN_HEAD_BRANCH}" != "main" ]]; then
              echo "âŒ Error: Workflow run is not from main branch (got: ${WORKFLOW_RUN_HEAD_BRANCH})" >&2
              exit 1
            fi

            echo "ğŸ” Workflow run triggered by successful Release Please workflow"
            echo "ğŸ“‹ Querying latest release as last-resort fallback..."

            # Verify GitHub token is available
            if [[ -z "${GITHUB_TOKEN}" ]]; then
              echo "âŒ Error: GITHUB_TOKEN environment variable is not set. Cannot authenticate with GitHub API." >&2
              exit 1
            fi

            # Query the latest release to get the tag that was just created
            # Use GITHUB_TOKEN for authentication to avoid rate limiting
            LATEST_RELEASE=$(gh api repos/${{ github.repository }}/releases/latest --jq '.tag_name')

            if [[ -z "${LATEST_RELEASE}" ]]; then
              echo "âŒ Error: Could not determine latest release tag" >&2
              exit 1
            fi

            if ! validate_semver "${LATEST_RELEASE}"; then
              exit 1
            fi

            echo "âœ… Found valid tag from latest release: ${LATEST_RELEASE}"
            echo "tag=${LATEST_RELEASE}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # No valid tag source found
          echo "âŒ Error: No valid tag detected from any source." >&2
          echo "Available sources:" >&2
          echo "  - workflow_dispatch: ${INPUT_TAG:-'not provided'}" >&2
          echo "  - release event: ${RELEASE_TAG:-'not available'}" >&2
          echo "  - tag push: ${REF:-'not a tag'}" >&2
          echo "  - workflow_run: ${WORKFLOW_RUN_NAME:-'not available'}" >&2
          exit 1

  create-release:
    needs: resolve-tag
    runs-on: ubuntu-22.04
    permissions:
      contents: write
      id-token: write
    steps:
      - uses: actions/checkout@v5

      - name: Create GitHub Release
        uses: taiki-e/create-gh-release-action@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: refs/tags/${{ needs.resolve-tag.outputs.tag }}

  build-and-package:
    needs: [create-release, resolve-tag]
    strategy:
      matrix:
        os: [ubuntu-22.04, macos-13, windows-2022]
    runs-on: ${{ matrix.os }}
    permissions:
      contents: write
    env:
      BIN_NAME: gold_digger
    steps:
      - uses: actions/checkout@v5

      - name: Install Rust (stable)
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: Swatinem/rust-cache@v2

      - name: Install just
        uses: extractions/setup-just@v3

      - name: Build release
        shell: bash
        run: |
          echo "ğŸ”¨ Building release with rustls (pure Rust TLS)..."
          just build-rustls

      - name: Upload binaries to Release
        uses: taiki-e/upload-rust-binary-action@v1
        with:
          bin: ${{ env.BIN_NAME }}
          tar: unix
          zip: windows
          ref: refs/tags/${{ needs.resolve-tag.outputs.tag }}
          features: rustls
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify built binaries
        shell: bash
        run: |
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            if [[ ! -f "target/release/${{ env.BIN_NAME }}.exe" ]]; then
              echo "Error: Windows binary not found at target/release/${{ env.BIN_NAME }}.exe" >&2
              exit 1
            fi
            echo "âœ… Windows binary verified: target/release/${{ env.BIN_NAME }}.exe"
            # Test binary execution
            ./target/release/${{ env.BIN_NAME }}.exe --version || { echo "Error: binary --version check failed" >&2; exit 1; }
          else
            if [[ ! -f "target/release/${{ env.BIN_NAME }}" ]]; then
              echo "Error: Unix binary not found at target/release/${{ env.BIN_NAME }}" >&2
              exit 1
            fi
            echo "âœ… Unix binary verified: target/release/${{ env.BIN_NAME }}"
            # Test binary execution
            ./target/release/${{ env.BIN_NAME }} --version || { echo "Error: binary --version check failed" >&2; exit 1; }
          fi

  sbom-and-sign:
    needs: [build-and-package, resolve-tag]
    runs-on: ubuntu-22.04
    permissions:
      contents: write
      id-token: write
    steps:
      - uses: actions/checkout@v5

      - name: Install syft
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.9.2

      - name: Install jq for JSON validation
        run: |
          sudo apt-get update && sudo apt-get install -y --no-install-recommends jq
        env:
          DEBIAN_FRONTEND: noninteractive

      - name: Download release assets
        run: |
          mkdir -p dist
          gh release download "${{ needs.resolve-tag.outputs.tag }}" --dir dist
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate SBOMs and checksums
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          mkdir -p sbom checksums
          echo "ğŸ“¦ Processing release artifacts..."

          artifact_count=0
          for f in dist/*; do
            if [ -f "$f" ] && [[ "$f" != *.sig ]] && [[ "$f" != *.crt ]]; then
              base=$(basename "$f")
              echo "Processing: $base"

              # Generate SBOM
              echo "  ğŸ” Generating SBOM..."
              syft packages "file:$f" -o cyclonedx-json > "sbom/${base}.sbom.cdx.json"

              # Verify SBOM was created and is valid JSON
              if ! jq empty "sbom/${base}.sbom.cdx.json" 2>/dev/null; then
                echo "âŒ Error: Invalid SBOM generated for $base" >&2
                exit 1
              fi

              # Generate SHA256 checksum
              echo "  ğŸ” Generating checksum..."
              # Run sha256sum from dist directory to get relative paths in output
              (cd dist && sha256sum "$base") > "checksums/${base}.sha256"

              artifact_count=$((artifact_count + 1))
            fi
          done

          if [ "$artifact_count" -eq 0 ]; then
            echo "âŒ Error: No artifacts found to process" >&2
            exit 1
          fi

          # Create consolidated checksums file
          echo "ğŸ“‹ Creating consolidated checksums file..."
          cat checksums/*.sha256 > checksums/SHA256SUMS

          echo "âœ… Processed $artifact_count artifacts successfully"

      - name: Upload SBOMs and checksums
        uses: softprops/action-gh-release@v2
        with:
          files: |
            sbom/*.sbom.cdx.json
            checksums/SHA256SUMS
            checksums/*.sha256
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Sign artifacts
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          echo "ğŸ” Signing release artifacts with Cosign keyless OIDC..."

          signed_count=0
          for f in dist/*; do
            if [ -f "$f" ] && [[ "$f" != *.sig ]] && [[ "$f" != *.crt ]]; then
              base=$(basename "$f")
              echo "Signing: $base"

              cosign sign-blob --yes "$f" \
                --output-signature "${f}.sig" \
                --output-certificate "${f}.crt"

              # Verify signature files were created
              if [[ ! -f "${f}.sig" ]] || [[ ! -f "${f}.crt" ]]; then
                echo "âŒ Error: Signature files not created for $base" >&2
                exit 1
              fi

              # Verify signature (basic validation)
              # Build expected certificate identity using exact workflow reference
              EXPECTED_IDENTITY="https://github.com/${{ github.repository }}/${{ github.workflow_ref }}"
              if ! cosign verify-blob --certificate "${f}.crt" --signature "${f}.sig" "$f" --certificate-identity "$EXPECTED_IDENTITY" --certificate-oidc-issuer "https://token.actions.githubusercontent.com"; then
                echo "âŒ Error: Signature verification failed for $base" >&2
                exit 1
              fi

              signed_count=$((signed_count + 1))
            fi
          done

          echo "âœ… Successfully signed $signed_count artifacts"

      - name: Verify all artifacts before upload
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          echo "ğŸ” Verifying all required artifacts are present..."

          # Check for SBOMs
          sbom_count=$(find sbom -name "*.sbom.cdx.json" | wc -l)
          if [ "$sbom_count" -eq 0 ]; then
            echo "âŒ Error: No SBOM files found" >&2
            exit 1
          fi
          echo "âœ… Found $sbom_count SBOM files"

          # Check for checksums
          if [[ ! -f "checksums/SHA256SUMS" ]]; then
            echo "âŒ Error: Consolidated checksums file not found" >&2
            exit 1
          fi
          checksum_count=$(find checksums -name "*.sha256" | wc -l)
          echo "âœ… Found consolidated checksums and $checksum_count individual checksum files"

          # Check for signatures
          sig_count=$(find dist -name "*.sig" | wc -l)
          crt_count=$(find dist -name "*.crt" | wc -l)
          if [ "$sig_count" -eq 0 ] || [ "$crt_count" -eq 0 ]; then
            echo "âŒ Error: Missing signature files (sig: $sig_count, crt: $crt_count)" >&2
            exit 1
          fi
          echo "âœ… Found $sig_count signature files and $crt_count certificate files"

          echo "ğŸ‰ All required artifacts verified successfully"

      - name: Upload signatures
        uses: softprops/action-gh-release@v2
        with:
          files: |
            dist/*.sig
            dist/*.crt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Trigger cargo-dist workflow for standardized distribution
  trigger-cargo-dist:
    needs: [sbom-and-sign, resolve-tag]
    runs-on: ubuntu-22.04
    permissions:
      actions: write
      contents: read
    steps:
      - name: Trigger cargo-dist workflow
        uses: actions/github-script@v7
        with:
          script: |
            const tag = '${{ needs.resolve-tag.outputs.tag }}';

            console.log(`ğŸš€ Triggering cargo-dist workflow for tag: ${tag}`);

            try {
              const result = await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'cargo-dist.yml',
                ref: 'main',
                inputs: {
                  tag: tag
                }
              });

              console.log('âœ… cargo-dist workflow triggered successfully');
              console.log(`ğŸ“‹ This will generate:`);
              console.log(`  ğŸš Shell installer script`);
              console.log(`  ğŸªŸ PowerShell installer script`);
              console.log(`  ğŸº Homebrew formula`);
              console.log(`  ğŸ“¦ MSI installer for Windows`);
              console.log(`  ğŸ” Additional signed artifacts`);

            } catch (error) {
              console.error('âŒ Failed to trigger cargo-dist workflow:', error);
              // Don't fail the main release workflow if cargo-dist trigger fails
              console.log('âš ï¸  Continuing with main release workflow...');
            }
